# Load libraries
library(data.table)
library(tidyverse) # Keep for potential data exploration, though not used in the main pipeline

#v3 i added  type.name %in% c( 'Bad Behaviour') which we need to account for the cards associated do bad behaviour. this is the only difference with v2


# --- 1. Data Loading and Initial Filtering  ---
all_events_v3 <- fread("all_events_v3.csv")
matches_info_all_events <- fread("matches_info_all_events.csv")

matches_info_1516 <- matches_info_all_events[season.season_name == "2015/2016"]
all_events_1516 <- all_events_v3[match_id %in% matches_info_1516$match_id]


########################## ########################## ########################## ########################## ########################## ########################## 
########################## NO Rescaling the data  ########################## ########################## ########################## 
########################## ########################## ########################## ########################## ########################## ########################## 

# --- 2. Build a Robust Minute-by-Minute Timeline ---
### It calculates stoppage time *per match* to avoid data loss or creating phantom minutes.

# 2a. Find the actual end minute for each half of EACH match
end_times_per_match <- all_events_1516[
  type.name == "Half End",
  .SD[which.max(minute)], # Select the entire row with the max minute for the group
  by = .(match_id, period)
][, .(match_id, period, end_minute = minute, end_second = second)] # Select and rename the desired columns

# 2b. Get the base match info needed for the timeline
base_match_data <- unique(matches_info_1516[, .(
  match_id,
  home_team_name = home_team.home_team_name,
  away_team_name = away_team.away_team_name
)])

# 2c. Join the end times to the match data
match_timings <- end_times_per_match[base_match_data, on = "match_id"]

# 2d. Generate the precise minute-by-minute timeline for all matches
# Separate the logic for each period to create the correct minute sequences.

# Timeline for Period 1
timeline_p1 <- match_timings[period == 1, .(minute = 0:end_minute), by = .(
  match_id,
  period,
  home_team_name,
  away_team_name
)]

# Timeline for Period 2
timeline_p2 <- match_timings[period == 2, .(minute = 45:end_minute), by = .(
  match_id,
  period,
  home_team_name,
  away_team_name
)]

# Combine the two timelines into one
stats_minute_1516 <- rbindlist(list(timeline_p1, timeline_p2))
# 2e. Initialize all state columns to integer zero (cleaner than NA)
state_cols <- c(
  "home_goals", "away_goals", "yellow_cards_home", "red_cards_home",
  "yellow_cards_away", "red_cards_away", "home_goal_now", "away_goal_now",
  "ych_now", "rch_now", "yca_now", "rca_now"
)
stats_minute_1516[, (state_cols) := 0L]

# 2f. Set order for efficient joins and calculations
setorder(stats_minute_1516, match_id, period, minute)


# --- 3. Process and Join Goal Events ---
# 3a. Filter for goal events
goal_events <- all_events_1516[shot.outcome.name == "Goal" | type.name == "Own Goal For"]

# 3b. Count goals per minute for each team
goals_per_minute <- goal_events[,
  .(goal_count = .N),
  by = .(match_id, period, minute, team.name)
]

# 3c. Update the main table with goals scored "now"
stats_minute_1516[goals_per_minute,
  on = .(match_id, period, minute, home_team_name = team.name),
  home_goal_now := i.goal_count
]
stats_minute_1516[goals_per_minute,
  on = .(match_id, period, minute, away_team_name = team.name),
  away_goal_now := i.goal_count
]


# --- 4. Process and Join Card Events ---
### CHANGE: We now keep second yellows separate to retain information.

# 4a. Filter for card events
card_events <- all_events_1516[
  (bad_behaviour.card.name %in% c("Yellow Card", "Red Card", "Second Yellow")) |
  (foul_committed.card.name %in% c("Yellow Card", "Red Card", "Second Yellow"))
]

# 4b. Consolidate card info into one column and count per type
card_events[, card_type := fcoalesce(bad_behaviour.card.name, foul_committed.card.name)]
cards_per_minute <- card_events[,
  .(
    yellows = sum(card_type == "Yellow Card", na.rm = TRUE),
    second_yellows = sum(card_type == "Second Yellow", na.rm = TRUE),
    reds = sum(card_type == "Red Card", na.rm = TRUE)
  ),
  by = .(match_id, period, minute, team.name)
]

# 4c. Update the main table with cards issued "now"
# A dismissal (player sent off) is a red OR a second yellow.
stats_minute_1516[cards_per_minute,
  on = .(match_id, period, minute, home_team_name = team.name),
  `:=`(ych_now = i.yellows, rch_now = i.reds + i.second_yellows)
]
stats_minute_1516[cards_per_minute,
  on = .(match_id, period, minute, away_team_name = team.name),
  `:=`(yca_now = i.yellows, rca_now = i.reds + i.second_yellows)
]


# --- 5. Calculate Cumulative Match State ---
### CHANGE: This logic is the same, but now it's applied to the cleanly generated data.
stats_minute_1516[, `:=`(
  home_goals = shift(cumsum(home_goal_now), fill = 0L),
  away_goals = shift(cumsum(away_goal_now), fill = 0L),
  yellow_cards_home = shift(cumsum(ych_now), fill = 0L),
  red_cards_home = shift(cumsum(rch_now), fill = 0L),
  yellow_cards_away = shift(cumsum(yca_now), fill = 0L),
  red_cards_away = shift(cumsum(rca_now), fill = 0L)
), by = .(match_id)]


# --- 6. Final Validation (Good practice) ---
# Get final state of each match from our new table
final_state <- stats_minute_1516[, .SD[.N], by = match_id]

# Compare with original match info
validation <- matches_info_1516[final_state, on = "match_id"]

# Check for score mismatches (should be 0)
mismatches <- validation[home_score != (home_goals + home_goal_now) | away_score != (away_goals + away_goal_now)]
print(paste("Found", nrow(mismatches), "mismatched scores."))


########################## ########################## ########################## ########################## ########################## ########################## 
########################## Rescaling the data: from 0 to 45 and from 45 to 90  ########################## ########################## ########################## 
########################## ########################## ########################## ########################## ########################## ########################## 


# --- 1. Renormalize Event Timestamps (Corrected Logic) ---

# Step 1.1: Find the TRUE end time (in total seconds) for each half from the ORIGINAL data.
# We use the original `all_events_1516` to ensure we get the real stoppage time.
true_end_times <- all_events_1516[
  type.name == "Half End",
  .(true_half_end_seconds = max(minute * 60 + second)),
  by = .(match_id, period)
]

# Step 1.2: Create a fresh copy of the events data for renormalization.
all_events_1516_renormalized <- copy(all_events_1516)

# Step 1.3: Merge these true end times onto our new table.
all_events_1516_renormalized <- merge(all_events_1516_renormalized, true_end_times, by = c("match_id", "period"))

# Step 1.4: Calculate the renormalized time in total seconds.
all_events_1516_renormalized[, renormalized_total_seconds := {
  # Get the event's time in total seconds from the start of the match.
  event_total_seconds <- minute * 60 + second
  
  # Apply scaling logic based on the period.
  if (period == 1) {
    # For P1, scale the event's time based on the half's true duration.
    # Handle the edge case where a half has zero duration to avoid division by zero.
    ifelse(true_half_end_seconds > 0,
           (event_total_seconds / true_half_end_seconds) * (45 * 60),
           0)
  } else { # period == 2
    # For P2, calculate time elapsed within the second half.
    time_in_p2 <- event_total_seconds - (45 * 60)
    duration_of_p2 <- true_half_end_seconds - (45 * 60)
    
    # Scale the time within P2 and add it back to the 45-minute mark.
    scaled_time_in_p2 <- ifelse(duration_of_p2 > 0,
                                (time_in_p2 / duration_of_p2) * (45 * 60),
                                0)
    (45 * 60) + scaled_time_in_p2
  }
}, by = 1:nrow(all_events_1516_renormalized)] # Apply row-by-row

# Step 1.5: Convert renormalized seconds back to minute and second columns.
# We also rename the original time columns to avoid confusion.
all_events_1516_renormalized[, `:=` (
  true_minute = minute,
  true_second = second,
  minute = floor(renormalized_total_seconds / 60),
  second = floor(renormalized_total_seconds %% 60)
)]

# Step 1.6: Clean up intermediate columns.
all_events_1516_renormalized[, `:=` (
  true_half_end_seconds = NULL,
  renormalized_total_seconds = NULL
)]


# --- 2. Build a FIXED Minute-by-Minute Timeline for Renormalized Data ---

# 2.1: Get the base match info needed for the timeline
base_match_data <- unique(matches_info_1516[, .(
  match_id,
  home_team_name = home_team.home_team_name,
  away_team_name = away_team.away_team_name
)])

# 2.2: Generate a FIXED timeline from 0-90 for all matches using a cross join (CJ).
# This is the standard, correct way to create a timeline for renormalized data.
stats_minute_1516_renormalized <- CJ(
  match_id = base_match_data$match_id,
  minute = 0:90,
  sorted = FALSE # We will sort later
)

# 2.3: Add period and team names.
stats_minute_1516_renormalized[minute < 45, period := 1]
stats_minute_1516_renormalized[minute >= 45, period := 2]
stats_minute_1516_renormalized <- merge(stats_minute_1516_renormalized, base_match_data, by = "match_id")


# 2.5: Initialize all state columns to integer zero.
state_cols <- c(
  "home_goals", "away_goals", "yellow_cards_home", "red_cards_home",
  "yellow_cards_away", "red_cards_away", "home_goal_now", "away_goal_now",
  "ych_now", "rch_now", "yca_now", "rca_now"
)
stats_minute_1516_renormalized[, (state_cols) := 0L]

# 2.6: Set order for efficient joins and calculations.
setorder(stats_minute_1516_renormalized, match_id, period, minute)


# --- 3. Process and Join Goal Events (using renormalized data) ---
goal_events <- all_events_1516_renormalized[shot.outcome.name == "Goal" | type.name == "Own Goal For"]
goals_per_minute <- goal_events[, .(goal_count = .N), by = .(match_id, period, minute, team.name)]

stats_minute_1516_renormalized[goals_per_minute, on = .(match_id, period, minute, home_team_name = team.name), home_goal_now := i.goal_count]
stats_minute_1516_renormalized[goals_per_minute, on = .(match_id, period, minute, away_team_name = team.name), away_goal_now := i.goal_count]


# --- 4. Process and Join Card Events (using renormalized data) ---
card_events <- all_events_1516_renormalized[
  (bad_behaviour.card.name %in% c("Yellow Card", "Red Card", "Second Yellow")) |
  (foul_committed.card.name %in% c("Yellow Card", "Red Card", "Second Yellow"))
]
card_events[, card_type := fcoalesce(bad_behaviour.card.name, foul_committed.card.name)]
cards_per_minute <- card_events[, .(
    yellows = sum(card_type == "Yellow Card", na.rm = TRUE),
    second_yellows = sum(card_type == "Second Yellow", na.rm = TRUE),
    reds = sum(card_type == "Red Card", na.rm = TRUE)
  ), by = .(match_id, period, minute, team.name)]

stats_minute_1516_renormalized[cards_per_minute, on = .(match_id, period, minute, home_team_name = team.name), `:=`(ych_now = i.yellows, rch_now = i.reds + i.second_yellows)]
stats_minute_1516_renormalized[cards_per_minute, on = .(match_id, period, minute, away_team_name = team.name), `:=`(yca_now = i.yellows, rca_now = i.reds + i.second_yellows)]


# --- 5. Calculate Cumulative Match State (for renormalized data) ---
stats_minute_1516_renormalized[, `:=`(
  home_goals = shift(cumsum(home_goal_now), fill = 0L),
  away_goals = shift(cumsum(away_goal_now), fill = 0L),
  yellow_cards_home = shift(cumsum(ych_now), fill = 0L),
  red_cards_home = shift(cumsum(rch_now), fill = 0L),
  yellow_cards_away = shift(cumsum(yca_now), fill = 0L),
  red_cards_away = shift(cumsum(rca_now), fill = 0L)
), by = .(match_id)]


# --- 6. Final Validation and Save ---
# (This validation is still useful to check if total goals match)
final_state_renorm <- stats_minute_1516_renormalized[, .SD[.N], by = match_id]
validation_renorm <- matches_info_1516[final_state_renorm, on = "match_id"]
mismatches_renorm <- validation_renorm[home_score != (home_goals + home_goal_now) | away_score != (away_goals + away_goal_now)]
print(paste("Found", nrow(mismatches_renorm), "mismatched scores in renormalized data."))



#write.csv(stats_minute_1516_renormalized, "stats_minute_1516_renormalized.csv", row.names = FALSE)
#write.csv(stats_minute_1516, "stats_minute_1516.csv", row.names = FALSE)
#write.csv(all_events_1516, "all_events_1516.csv", row.names = FALSE)
#write.csv(all_events_1516_renormalized, "all_events_1516_renormalized.csv", row.names = FALSE)
#write.csv(matches_info_1516, "matches_info_1516.csv", row.names = FALSE)

