"score_state",
"player_advantage_state")]
# 1. From `dataco`, select only the match_id and the pre-match expected goals.
pre_match_strengths <- dataco[, .(match_id, expH, expA)]
# 2. Merge these strengths into your state_data dataframe.
# The `merge` function will use the common column `match_id` to align the data correctly.
# It will automatically repeat the expH and expA values for every minute of each match.
state_data_full <- merge(state_data, pre_match_strengths, by = "match_id")
# 3. (Optional but recommended) Set the order for readability.
setorder(state_data_full, match_id, minute)
# 1. Create the 'home' perspective dataframe
home_df <- state_data_full[, .(
match_id,
minute,
team = "home",
goal_scored = home_goal_now,
# Predictors from the home team's perspective
score_diff = score_state, # (home_goals - away_goals)
player_diff = player_advantage_state, # (away_reds - home_reds)
own_expG = expH,
opponent_expG = expA
)]
# 2. Create the 'away' perspective dataframe
away_df <- state_data_full[, .(
match_id,
minute,
team = "away",
goal_scored = away_goal_now,
# Predictors from the away team's perspective (signs are flipped)
score_diff = -score_state, # becomes (away_goals - home_goals)
player_diff = -player_advantage_state, # becomes (home_reds - away_reds)
own_expG = expA,
opponent_expG = expH
)]
# 3. Combine the two dataframes into one long format
model_data <- rbind(home_df, away_df)
# 4. Set order for readability
setorder(model_data, match_id, minute, team)
# --- Create a proper Train/Dev/Test Split by Match ---
# Get a list of all unique match IDs
all_matches <- unique(model_data$match_id)
set.seed(42) # for reproducibility
# Step 1: Split into training (80%) and a temporary set (20%)
train_match_ids <- sample(all_matches, size = floor(0.8 * length(all_matches)))
temp_matches <- all_matches[!all_matches %in% train_match_ids]
# Step 2: Split the temporary set into validation (10%) and test (10%)
dev_match_ids <- sample(temp_matches, size = floor(0.5 * length(temp_matches)))
test_match_ids <- temp_matches[!temp_matches %in% dev_match_ids]
# Create the final dataframes
train_data <- model_data[match_id %in% train_match_ids]
dev_data <- model_data[match_id %in% dev_match_ids]
test_data <- model_data[match_id %in% test_match_ids]
# --- Initialize a data frame to store model comparison results ---
results_table <- data.frame(
Model_Name = character(),
Model_Description = character(),
Log_Loss = numeric(),
Brier_Score = numeric()
)
################ ---  m1 Train model and Evaluate the Model. LINEAR GLM ---
# 1. Train your GLM only on the training data
goal_model_m1<- glm(goal_scored ~ score_diff + player_diff + own_expG + opponent_expG,
data = train_data, family = binomial)
# 2. Make predictions on the unseen test data
dev_data$predicted_prob_m1 <- predict(goal_model_m1, newdata = dev_data, type = "response")
# 3. Calculate Log-Loss (with clipping for numerical stability)
eps <- 1e-15 # A small epsilon to prevent log(0)
clipped_probs <- pmin(pmax(dev_data$predicted_prob_m1, eps), 1 - eps)
log_loss_m1 <- -mean(dev_data$goal_scored * log(clipped_probs) +
(1 - dev_data$goal_scored) * log(1 - clipped_probs))
# 4. Calculate Brier Score
brier_score_m1 <- mean((dev_data$predicted_prob_m1 - dev_data$goal_scored)^2)
# 4. Add results to the summary table
results_table <- rbind(results_table, data.frame(
Model_Name = "goal_model_m1",
Model_Description = "Baseline Linear GLM",
Log_Loss = log_loss_m1,
Brier_Score = brier_score_m1
))
################ --- Train model and Evaluate the Model. GAM Add Spline on Minute ---
goal_model_m2<- gam(goal_scored ~ s(minute) + score_diff + player_diff + own_expG + opponent_expG,
data = train_data, family = binomial)
# 2. Make predictions on the unseen test data
dev_data$predicted_prob_m2 <- predict(goal_model_m2, newdata = dev_data, type = "response")
# 3. Calculate Log-Loss (with clipping for numerical stability)
eps <- 1e-15 # A small epsilon to prevent log(0)
clipped_probs <- pmin(pmax(dev_data$predicted_prob_m2, eps), 1 - eps)
log_loss_m2 <- -mean(dev_data$goal_scored * log(clipped_probs) +
(1 - dev_data$goal_scored) * log(1 - clipped_probs))
# 4. Calculate Brier Score
brier_score_m2 <- mean((dev_data$predicted_prob_m2 - dev_data$goal_scored)^2)
# 4. Add results to the summary table
results_table <- rbind(results_table, data.frame(
Model_Name = "goal_model_m2",
Model_Description = "GAM s(goals)",
Log_Loss = log_loss_m2,
Brier_Score = brier_score_m2
))
################ --- Train model and Evaluate the Model. GAM Add Spline on Minuteand score_difference ---
goal_model_m3<- gam(goal_scored ~ s(minute) + s(score_diff) + player_diff + own_expG + opponent_expG,
data = train_data, family = binomial)
# 2. Make predictions on the unseen test data
dev_data$predicted_prob_m3 <- predict(goal_model_m3, newdata = dev_data, type = "response")
# 3. Calculate Log-Loss (with clipping for numerical stability)
eps <- 1e-15 # A small epsilon to prevent log(0)
clipped_probs <- pmin(pmax(dev_data$predicted_prob_m3, eps), 1 - eps)
log_loss_m3 <- -mean(dev_data$goal_scored * log(clipped_probs) +
(1 - dev_data$goal_scored) * log(1 - clipped_probs))
# 4. Calculate Brier Score
brier_score_m3 <- mean((dev_data$predicted_prob_m3 - dev_data$goal_scored)^2)
# 4. Add results to the summary table
results_table <- rbind(results_table, data.frame(
Model_Name = "goal_model_m3",
Model_Description = "GAM s(goals), s(score_diff)",
Log_Loss = log_loss_m3,
Brier_Score = brier_score_m3
))
################ --- Train model and Evaluate the Model. GAM Add Spline on Minuteand player_diff ---
goal_model_m4<- gam(goal_scored ~ s(minute) + score_diff + s(player_diff) + own_expG + opponent_expG,
data = train_data, family = binomial)
# Load libraries
library(data.table)
library(dplyr)
library(ggplot2)
library(tidyverse)
library(mgcv)
library(plotly)
#Load the data
matches <- fread("matches_info_1516.csv")
dataco <- fread("dataco_all_events_1516_fitprob.csv")
events <- fread("all_events_1516_renormalized.csv")
statsr <- fread("stats_minute_1516_renormalized.csv")
stats <- fread("stats_minute_1516.csv")
################### Final Data preparation #########################################################
#1 Prepare the data. For every minute of the match we want 1) goal home or goal away in that minute? 2) state of the match (current result and players on  the field for both teams).
#Sanity check, no more of one goal per minute
all(statsr$home_goal_now %in% c(0, 1)) && all(statsr$away_goal_now %in% c(0, 1))
#From the home team perspective
statsr$score_state <- statsr$home_goals - statsr$away_goals
statsr$player_advantage_state <- statsr$red_cards_away - statsr$red_cards_home
state_data <- statsr[, c("match_id",
"minute",
"home_goal_now",
"away_goal_now",
"score_state",
"player_advantage_state")]
# 1. From `dataco`, select only the match_id and the pre-match expected goals.
pre_match_strengths <- dataco[, .(match_id, expH, expA)]
# 2. Merge these strengths into your state_data dataframe.
# The `merge` function will use the common column `match_id` to align the data correctly.
# It will automatically repeat the expH and expA values for every minute of each match.
state_data_full <- merge(state_data, pre_match_strengths, by = "match_id")
# 3. (Optional but recommended) Set the order for readability.
setorder(state_data_full, match_id, minute)
# 1. Create the 'home' perspective dataframe
home_df <- state_data_full[, .(
match_id,
minute,
team = "home",
goal_scored = home_goal_now,
# Predictors from the home team's perspective
score_diff = score_state, # (home_goals - away_goals)
player_diff = player_advantage_state, # (away_reds - home_reds)
own_expG = expH,
opponent_expG = expA
)]
# 2. Create the 'away' perspective dataframe
away_df <- state_data_full[, .(
match_id,
minute,
team = "away",
goal_scored = away_goal_now,
# Predictors from the away team's perspective (signs are flipped)
score_diff = -score_state, # becomes (away_goals - home_goals)
player_diff = -player_advantage_state, # becomes (home_reds - away_reds)
own_expG = expA,
opponent_expG = expH
)]
# 3. Combine the two dataframes into one long format
model_data <- rbind(home_df, away_df)
# 4. Set order for readability
setorder(model_data, match_id, minute, team)
# --- Create a proper Train/Dev/Test Split by Match ---
# Get a list of all unique match IDs
all_matches <- unique(model_data$match_id)
set.seed(42) # for reproducibility
# Step 1: Split into training (80%) and a temporary set (20%)
train_match_ids <- sample(all_matches, size = floor(0.8 * length(all_matches)))
temp_matches <- all_matches[!all_matches %in% train_match_ids]
# Step 2: Split the temporary set into validation (10%) and test (10%)
dev_match_ids <- sample(temp_matches, size = floor(0.5 * length(temp_matches)))
test_match_ids <- temp_matches[!temp_matches %in% dev_match_ids]
# Create the final dataframes
train_data <- model_data[match_id %in% train_match_ids]
dev_data <- model_data[match_id %in% dev_match_ids]
test_data <- model_data[match_id %in% test_match_ids]
# --- Initialize a data frame to store model comparison results ---
results_table <- data.frame(
Model_Name = character(),
Model_Description = character(),
Log_Loss = numeric(),
Brier_Score = numeric()
)
################ ---  m1 Train model and Evaluate the Model. LINEAR GLM ---
# 1. Train your GLM only on the training data
goal_model_m1<- glm(goal_scored ~ score_diff + player_diff + own_expG + opponent_expG,
data = train_data, family = binomial)
# 2. Make predictions on the unseen test data
dev_data$predicted_prob_m1 <- predict(goal_model_m1, newdata = dev_data, type = "response")
# 3. Calculate Log-Loss (with clipping for numerical stability)
eps <- 1e-15 # A small epsilon to prevent log(0)
clipped_probs <- pmin(pmax(dev_data$predicted_prob_m1, eps), 1 - eps)
log_loss_m1 <- -mean(dev_data$goal_scored * log(clipped_probs) +
(1 - dev_data$goal_scored) * log(1 - clipped_probs))
# 4. Calculate Brier Score
brier_score_m1 <- mean((dev_data$predicted_prob_m1 - dev_data$goal_scored)^2)
# 4. Add results to the summary table
results_table <- rbind(results_table, data.frame(
Model_Name = "goal_model_m1",
Model_Description = "Baseline Linear GLM",
Log_Loss = log_loss_m1,
Brier_Score = brier_score_m1
))
################ --- Train model and Evaluate the Model. GAM Add Spline on Minute ---
goal_model_m2<- gam(goal_scored ~ s(minute) + score_diff + player_diff + own_expG + opponent_expG,
data = train_data, family = binomial)
# 2. Make predictions on the unseen test data
dev_data$predicted_prob_m2 <- predict(goal_model_m2, newdata = dev_data, type = "response")
# 3. Calculate Log-Loss (with clipping for numerical stability)
eps <- 1e-15 # A small epsilon to prevent log(0)
clipped_probs <- pmin(pmax(dev_data$predicted_prob_m2, eps), 1 - eps)
log_loss_m2 <- -mean(dev_data$goal_scored * log(clipped_probs) +
(1 - dev_data$goal_scored) * log(1 - clipped_probs))
# 4. Calculate Brier Score
brier_score_m2 <- mean((dev_data$predicted_prob_m2 - dev_data$goal_scored)^2)
# 4. Add results to the summary table
results_table <- rbind(results_table, data.frame(
Model_Name = "goal_model_m2",
Model_Description = "GAM s(goals)",
Log_Loss = log_loss_m2,
Brier_Score = brier_score_m2
))
################ --- Train model and Evaluate the Model. GAM Add Spline on Minuteand score_difference ---
goal_model_m3<- gam(goal_scored ~ s(minute) + s(score_diff) + player_diff + own_expG + opponent_expG,
data = train_data, family = binomial)
# 2. Make predictions on the unseen test data
dev_data$predicted_prob_m3 <- predict(goal_model_m3, newdata = dev_data, type = "response")
# 3. Calculate Log-Loss (with clipping for numerical stability)
eps <- 1e-15 # A small epsilon to prevent log(0)
clipped_probs <- pmin(pmax(dev_data$predicted_prob_m3, eps), 1 - eps)
log_loss_m3 <- -mean(dev_data$goal_scored * log(clipped_probs) +
(1 - dev_data$goal_scored) * log(1 - clipped_probs))
# 4. Calculate Brier Score
brier_score_m3 <- mean((dev_data$predicted_prob_m3 - dev_data$goal_scored)^2)
# 4. Add results to the summary table
results_table <- rbind(results_table, data.frame(
Model_Name = "goal_model_m3",
Model_Description = "GAM s(goals), s(score_diff)",
Log_Loss = log_loss_m3,
Brier_Score = brier_score_m3
))
#Print results ordered by Log_Loss
print(results_table[order(results_table$Log_Loss), ])
################ --- Train model and Evaluate the Model. Spline on Minute and interaction with score_diff ---
goal_model_m4 <- gam(goal_scored ~ s(minute) + s(score_diff) + ti(minute, score_diff) +
player_diff + own_expG + opponent_expG,
data = train_data, family = binomial)
# 2. Make predictions on the unseen test data
dev_data$predicted_prob_m4 <- predict(goal_model_m4, newdata = dev_data, type = "response")
# 3. Calculate Log-Loss (with clipping for numerical stability)
eps <- 1e-15 # A small epsilon to prevent log(0)
clipped_probs <- pmin(pmax(dev_data$predicted_prob_m4, eps), 1 - eps)
log_loss_m4 <- -mean(dev_data$goal_scored * log(clipped_probs) +
(1 - dev_data$goal_scored) * log(1 - clipped_probs))
# 4. Calculate Brier Score
brier_score_m4 <- mean((dev_data$predicted_prob_m4 - dev_data$goal_scored)^2)
# 4. Add results to the summary table
results_table <- rbind(results_table, data.frame(
Model_Name = "goal_model_m4",
Model_Description = "GAM s(goals), minute*score_diff",
Log_Loss = log_loss_m4,
Brier_Score = brier_score_m4
))
#Print results ordered by Log_Loss
print(results_table[order(results_table$Log_Loss), ])
################ --- Train model and Evaluate the Model.Interaction with score_diff ---
goal_model_m5 <- gam(goal_scored ~ minute + score_diff + ti(minute, score_diff) +
player_diff + own_expG + opponent_expG,
data = train_data, family = binomial)
# 2. Make predictions on the unseen test data
dev_data$predicted_prob_m5 <- predict(goal_model_m5, newdata = dev_data, type = "response")
# 3. Calculate Log-Loss (with clipping for numerical stability)
eps <- 1e-15 # A small epsilon to prevent log(0)
clipped_probs <- pmin(pmax(dev_data$predicted_prob_m5, eps), 1 - eps)
log_loss_m5 <- -mean(dev_data$goal_scored * log(clipped_probs) +
(1 - dev_data$goal_scored) * log(1 - clipped_probs))
# 4. Calculate Brier Score
brier_score_m5 <- mean((dev_data$predicted_prob_m5 - dev_data$goal_scored)^2)
# 4. Add results to the summary table
results_table <- rbind(results_table, data.frame(
Model_Name = "goal_model_m5",
Model_Description = "GAM minute*score_diff",
Log_Loss = log_loss_m5,
Brier_Score = brier_score_m5
))
#Print results ordered by Log_Loss
print(results_table[order(results_table$Log_Loss), ])
# Load libraries
library(data.table)
library(dplyr)
library(ggplot2)
library(tidyverse)
library(mgcv)
library(plotly)
#Load the data
matches <- fread("matches_info_1516.csv")
dataco <- fread("dataco_all_events_1516_fitprob.csv")
events <- fread("all_events_1516_renormalized.csv")
statsr <- fread("stats_minute_1516_renormalized.csv")
stats <- fread("stats_minute_1516.csv")
################### Final Data preparation #########################################################
#1 Prepare the data. For every minute of the match we want 1) goal home or goal away in that minute? 2) state of the match (current result and players on  the field for both teams).
#Sanity check, no more of one goal per minute
all(statsr$home_goal_now %in% c(0, 1)) && all(statsr$away_goal_now %in% c(0, 1))
#From the home team perspective
statsr$score_state <- statsr$home_goals - statsr$away_goals
statsr$player_advantage_state <- statsr$red_cards_away - statsr$red_cards_home
state_data <- statsr[, c("match_id",
"minute",
"home_goal_now",
"away_goal_now",
"score_state",
"player_advantage_state")]
# 1. From `dataco`, select only the match_id and the pre-match expected goals.
pre_match_strengths <- dataco[, .(match_id, expH, expA)]
# 2. Merge these strengths into your state_data dataframe.
# The `merge` function will use the common column `match_id` to align the data correctly.
# It will automatically repeat the expH and expA values for every minute of each match.
state_data_full <- merge(state_data, pre_match_strengths, by = "match_id")
# 3. (Optional but recommended) Set the order for readability.
setorder(state_data_full, match_id, minute)
# 1. Create the 'home' perspective dataframe
home_df <- state_data_full[, .(
match_id,
minute,
team = "home",
goal_scored = home_goal_now,
# Predictors from the home team's perspective
score_diff = score_state, # (home_goals - away_goals)
player_diff = player_advantage_state, # (away_reds - home_reds)
own_expG = expH,
opponent_expG = expA
)]
# 2. Create the 'away' perspective dataframe
away_df <- state_data_full[, .(
match_id,
minute,
team = "away",
goal_scored = away_goal_now,
# Predictors from the away team's perspective (signs are flipped)
score_diff = -score_state, # becomes (away_goals - home_goals)
player_diff = -player_advantage_state, # becomes (home_reds - away_reds)
own_expG = expA,
opponent_expG = expH
)]
# 3. Combine the two dataframes into one long format
model_data <- rbind(home_df, away_df)
# 4. Set order for readability
setorder(model_data, match_id, minute, team)
# --- Create a proper Train/Dev/Test Split by Match ---
# Get a list of all unique match IDs
all_matches <- unique(model_data$match_id)
set.seed(42) # for reproducibility
# Step 1: Split into training (80%) and a temporary set (20%)
train_match_ids <- sample(all_matches, size = floor(0.8 * length(all_matches)))
temp_matches <- all_matches[!all_matches %in% train_match_ids]
# Step 2: Split the temporary set into validation (10%) and test (10%)
dev_match_ids <- sample(temp_matches, size = floor(0.5 * length(temp_matches)))
test_match_ids <- temp_matches[!temp_matches %in% dev_match_ids]
# Create the final dataframes
train_data <- model_data[match_id %in% train_match_ids]
dev_data <- model_data[match_id %in% dev_match_ids]
test_data <- model_data[match_id %in% test_match_ids]
# --- Initialize a data frame to store model comparison results ---
results_table <- data.frame(
Model_Name = character(),
Model_Description = character(),
Log_Loss = numeric(),
Brier_Score = numeric()
)
################ ---  m1 Train model and Evaluate the Model. LINEAR GLM ---
# 1. Train your GLM only on the training data
goal_model_m1<- glm(goal_scored ~ score_diff + player_diff + own_expG + opponent_expG,
data = train_data, family = binomial)
# 2. Make predictions on the unseen test data
dev_data$predicted_prob_m1 <- predict(goal_model_m1, newdata = dev_data, type = "response")
# 3. Calculate Log-Loss (with clipping for numerical stability)
eps <- 1e-15 # A small epsilon to prevent log(0)
clipped_probs <- pmin(pmax(dev_data$predicted_prob_m1, eps), 1 - eps)
log_loss_m1 <- -mean(dev_data$goal_scored * log(clipped_probs) +
(1 - dev_data$goal_scored) * log(1 - clipped_probs))
# 4. Calculate Brier Score
brier_score_m1 <- mean((dev_data$predicted_prob_m1 - dev_data$goal_scored)^2)
# 4. Add results to the summary table
results_table <- rbind(results_table, data.frame(
Model_Name = "goal_model_m1",
Model_Description = "vanilla GLM",
Log_Loss = log_loss_m1,
Brier_Score = brier_score_m1
))
################ --- Train model and Evaluate the Model. GAM Add Spline on Minute ---
goal_model_m2<- gam(goal_scored ~ s(minute) + score_diff + player_diff + own_expG + opponent_expG,
data = train_data, family = binomial)
# 2. Make predictions on the unseen test data
dev_data$predicted_prob_m2 <- predict(goal_model_m2, newdata = dev_data, type = "response")
# 3. Calculate Log-Loss (with clipping for numerical stability)
eps <- 1e-15 # A small epsilon to prevent log(0)
clipped_probs <- pmin(pmax(dev_data$predicted_prob_m2, eps), 1 - eps)
log_loss_m2 <- -mean(dev_data$goal_scored * log(clipped_probs) +
(1 - dev_data$goal_scored) * log(1 - clipped_probs))
# 4. Calculate Brier Score
brier_score_m2 <- mean((dev_data$predicted_prob_m2 - dev_data$goal_scored)^2)
# 4. Add results to the summary table
results_table <- rbind(results_table, data.frame(
Model_Name = "goal_model_m2",
Model_Description = "s(minutes)",
Log_Loss = log_loss_m2,
Brier_Score = brier_score_m2
))
################ --- Train model and Evaluate the Model. GAM Add Spline on Minuteand score_difference ---
goal_model_m3<- gam(goal_scored ~ s(minute) + s(score_diff) + player_diff + own_expG + opponent_expG,
data = train_data, family = binomial)
# 2. Make predictions on the unseen test data
dev_data$predicted_prob_m3 <- predict(goal_model_m3, newdata = dev_data, type = "response")
# 3. Calculate Log-Loss (with clipping for numerical stability)
eps <- 1e-15 # A small epsilon to prevent log(0)
clipped_probs <- pmin(pmax(dev_data$predicted_prob_m3, eps), 1 - eps)
log_loss_m3 <- -mean(dev_data$goal_scored * log(clipped_probs) +
(1 - dev_data$goal_scored) * log(1 - clipped_probs))
# 4. Calculate Brier Score
brier_score_m3 <- mean((dev_data$predicted_prob_m3 - dev_data$goal_scored)^2)
# 4. Add results to the summary table
results_table <- rbind(results_table, data.frame(
Model_Name = "goal_model_m3",
Model_Description = "s(minutes), s(score_diff)",
Log_Loss = log_loss_m3,
Brier_Score = brier_score_m3
))
################ --- Train model and Evaluate the Model. Spline on Minute and interaction with score_diff ---
goal_model_m4 <- gam(goal_scored ~ s(minute) + s(score_diff) + ti(minute, score_diff) +
player_diff + own_expG + opponent_expG,
data = train_data, family = binomial)
# 2. Make predictions on the unseen test data
dev_data$predicted_prob_m4 <- predict(goal_model_m4, newdata = dev_data, type = "response")
# 3. Calculate Log-Loss (with clipping for numerical stability)
eps <- 1e-15 # A small epsilon to prevent log(0)
clipped_probs <- pmin(pmax(dev_data$predicted_prob_m4, eps), 1 - eps)
log_loss_m4 <- -mean(dev_data$goal_scored * log(clipped_probs) +
(1 - dev_data$goal_scored) * log(1 - clipped_probs))
# 4. Calculate Brier Score
brier_score_m4 <- mean((dev_data$predicted_prob_m4 - dev_data$goal_scored)^2)
# 4. Add results to the summary table
results_table <- rbind(results_table, data.frame(
Model_Name = "goal_model_m4",
Model_Description = "s(minutes),s(score_diff), minute*score_diff",
Log_Loss = log_loss_m4,
Brier_Score = brier_score_m4
))
################ --- Train model and Evaluate the Model.Interaction with score_diff ---
goal_model_m5 <- gam(goal_scored ~ minute + score_diff + ti(minute, score_diff) +
player_diff + own_expG + opponent_expG,
data = train_data, family = binomial)
# 2. Make predictions on the unseen test data
dev_data$predicted_prob_m5 <- predict(goal_model_m5, newdata = dev_data, type = "response")
# 3. Calculate Log-Loss (with clipping for numerical stability)
eps <- 1e-15 # A small epsilon to prevent log(0)
clipped_probs <- pmin(pmax(dev_data$predicted_prob_m5, eps), 1 - eps)
log_loss_m5 <- -mean(dev_data$goal_scored * log(clipped_probs) +
(1 - dev_data$goal_scored) * log(1 - clipped_probs))
# 4. Calculate Brier Score
brier_score_m5 <- mean((dev_data$predicted_prob_m5 - dev_data$goal_scored)^2)
# 4. Add results to the summary table
results_table <- rbind(results_table, data.frame(
Model_Name = "goal_model_m5",
Model_Description = "minute*score_diff",
Log_Loss = log_loss_m5,
Brier_Score = brier_score_m5
))
#Print results ordered by Log_Loss
print(results_table[order(results_table$Log_Loss), ])
################ --- Train model and Evaluate the Model.Interaction with score_diff ---
goal_model_m6 <- gam(goal_scored ~ s(minute) + score_diff + ti(minute, score_diff) +
player_diff + own_expG + opponent_expG,
data = train_data, family = binomial)
# 2. Make predictions on the unseen test data
dev_data$predicted_prob_m6 <- predict(goal_model_m6, newdata = dev_data, type = "response")
# 3. Calculate Log-Loss (with clipping for numerical stability)
eps <- 1e-15 # A small epsilon to prevent log(0)
clipped_probs <- pmin(pmax(dev_data$predicted_prob_m6, eps), 1 - eps)
log_loss_m6 <- -mean(dev_data$goal_scored * log(clipped_probs) +
(1 - dev_data$goal_scored) * log(1 - clipped_probs))
# 4. Calculate Brier Score
brier_score_m6 <- mean((dev_data$predicted_prob_m6 - dev_data$goal_scored)^2)
# 4. Add results to the summary table
results_table <- rbind(results_table, data.frame(
Model_Name = "goal_model_m6",
Model_Description = "s(minute), minute*score_diff",
Log_Loss = log_loss_m6,
Brier_Score = brier_score_m6
))
#Print results ordered by Log_Loss
print(results_table[order(results_table$Log_Loss), ])
